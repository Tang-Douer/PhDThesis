% Generated by ADiMat 0.6.0-4728
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= Imfw, U, theta
% AD_DVARS= xy_fronts

% Script to create huygens expancion for ANY closed initial perimeter
% Need to chance REF system (adapted on equations)!! (centered on the curve!) (previously created only for circular ignition fronts)
%
% CERTEC-ORios-07/14-
%
%   INPUTS
%   theta    wind direction DEG
%   xiyi     initial perimeter curve 
%   U        wind speed
%   fuel_depth_map.mat   Workspace generated with Fuel_depth_Map.m % loads fuel map and georeferencing!
%   dt      time step seg
%   tf       forcasted fronts
%   OUTPUTS
%   xy_fronts{t,x-y(1-2)} CELL ARRAY CANVIANT-ho!!
%
function [g_xy_fronts, xy_fronts]= g_expansion_f(g_Imfw, Imfw, g_U, U, g_theta, theta, xiyi, fuel_depth, dt, tf)
   %***************************%
   flag_real= 0; % if 0 = real!,     1 = elliptical
   %***************************%
   flag_method= 3; % if 3 = euler,     2 = my,     1 = Richard93
   %***************************%
   flag_smooth= 0; % if 0 = NO smooth, 1 = YES splines 2 neighbors
   %***************************%
   %color_map=colormap(lines);
   %color_map=colormap(hsv(128));
   %load('fuel_depth_map.mat','fuel_depth') % loads fuel map and georeferencing!
   
   %----could be set as inputs----
   %dt    = 1; % time step seg
   %tf    = 8;  % forcasted fronts
   tmp_expansion_f_00071= tf- 2; %Fronts number correction
   % Update detected: tf= some_expression(tf,...)
   tf= tmp_expansion_f_00071;
   tt= 0: dt: tf; 
   Nt= length(tt); 
   
   g_tmp_expansion_f_00000= g_theta* pi;
   tmp_expansion_f_00000= theta* pi;
   g_tmp_expansion_f_00001= adimat_g_mrdivide1(g_tmp_expansion_f_00000, tmp_expansion_f_00000, 180);
   tmp_expansion_f_00001= tmp_expansion_f_00000/ 180;
   tmp_expansion_f_00002= pi/ 2;
   g_theta= g_tmp_expansion_f_00001+ g_zeros(size(tmp_expansion_f_00002));
   theta= tmp_expansion_f_00001+ tmp_expansion_f_00002; %DEG->RAD -90º OFFSET!!!!              %RAD wind direction, can depend on time!! (modify!)
   %theta = 0;
   Nds= 20; % number of discretized points
   %n=length(s); % time steps (adding 0 (initial) time
   %% REAL ignition or SYNTHETIC
   if flag_real== 0%%%%%load('isochrons_mod.mat', 'isochrons_mod')
      %xiyi=isochrons_mod.xy{9};
      %%%%%xiyi=isochrons_mod.xy{10};
      % Aranging and creating mirror symetry!! /HALF CURVE!!! 
      tmp_expansion_f_00072= flipud(xiyi); 
      % Update detected: xiyi= some_expression(xiyi,...)
      xiyi= tmp_expansion_f_00072;
      xRef= min(xiyi(: , 1)); 
      yRef= min(xiyi(: , 2)); 
      %xiyi(:,1)=xiyi(:,1);
      %xiyi(:,2)=xiyi(:,2);
      
      %     b=xiyi(1:end-1,:);
      %     b(:,2)=2*yRef-b(:,2);
      %     b=flipud(b);
      %     xiyi=[xiyi;b]; %MIRALL SIMETRIC
      
      if xiyi(1, : )~= xiyi(end, : )
         tmp_expansion_f_00073= [xiyi;
            xiyi(1, : )]; %Close perimeter if open
         % Update detected: xiyi= some_expression(xiyi,...)
         xiyi= tmp_expansion_f_00073;
      end
      
      xi= xiyi(: , 1); 
      yi= xiyi(: , 2); 
      %s=0:2*pi/(length(xi)-1):2*pi;
      %n=length(s);
      %m =Nt+1;
   else 
      %% TEST with circular ignition
      Nds= 100; 
      s= 0: 2* pi/ (Nds- 1): 2* pi; 
      %s=-pi/2:2*pi/(Nds-1):3*pi/2;
      n= length(s); 
      m= Nt+ 1; 
      x= zeros(n, m); %+1 to close the perimeter last point equals first
      y= zeros(n, m); 
      r= 10; %m %initial radius
      xi= 0.7* r.* cos(s)' + 300; 
      yi= 0.2* r.* sin(s)' + 300; 
      xRef= mean(xi); 
      yRef= min(yi); 
      %close it
      %xi(n+1,1)=xi(1,1); %fallava pq si augemntes la dimensió es creen zeros
      %yi(n+1,1)=yi(1,1);
      
   end
   
   % SPACE DEPENDENT FUEL!!!!
   g_RoS= g_Imfw.* fuel_depth;
   RoS= Imfw.* fuel_depth; %fuel_depth loaded in 'fuel_depth_map.mat' workspace!
   g_tmp_expansion_f_00003= 0.2566* g_U;
   tmp_expansion_f_00003= 0.2566* U;
   g_tmp_exp_00000= g_tmp_expansion_f_00003.* exp(tmp_expansion_f_00003);
   tmp_exp_00000= exp(tmp_expansion_f_00003);
   g_tmp_expansion_f_00004= 0.936* g_tmp_exp_00000;
   tmp_expansion_f_00004= 0.936* tmp_exp_00000;
   g_tmp_expansion_f_00005= -0.1548* g_U;
   tmp_expansion_f_00005= -0.1548* U;
   g_tmp_exp_00001= g_tmp_expansion_f_00005.* exp(tmp_expansion_f_00005);
   tmp_exp_00001= exp(tmp_expansion_f_00005);
   g_tmp_expansion_f_00006= 0.461* g_tmp_exp_00001;
   tmp_expansion_f_00006= 0.461* tmp_exp_00001;
   g_LB= g_tmp_expansion_f_00004+ g_tmp_expansion_f_00006+ g_zeros(1);
   LB= tmp_expansion_f_00004+ tmp_expansion_f_00006- 0.397; 
   g_tmp_expansion_f_00007= adimat_g_pow_left(g_LB, LB, 2);
   tmp_expansion_f_00007= LB^ 2;
   g_tmp_expansion_f_00008= g_tmp_expansion_f_00007+ g_zeros(1);
   tmp_expansion_f_00008= tmp_expansion_f_00007- 1;
   tmp_sqrt_00000= sqrt(tmp_expansion_f_00008);
   g_tmp_sqrt_00000= g_tmp_expansion_f_00008./ (2.* tmp_sqrt_00000);
   g_tmp_expansion_f_00009= g_LB+ g_tmp_sqrt_00000;
   tmp_expansion_f_00009= LB+ tmp_sqrt_00000;
   g_tmp_expansion_f_00010= adimat_g_pow_left(g_LB, LB, 2);
   tmp_expansion_f_00010= LB^ 2;
   g_tmp_expansion_f_00011= g_tmp_expansion_f_00010+ g_zeros(1);
   tmp_expansion_f_00011= tmp_expansion_f_00010- 1;
   tmp_sqrt_00001= sqrt(tmp_expansion_f_00011);
   g_tmp_sqrt_00001= g_tmp_expansion_f_00011./ (2.* tmp_sqrt_00001);
   g_tmp_expansion_f_00012= g_LB- g_tmp_sqrt_00001;
   tmp_expansion_f_00012= LB- tmp_sqrt_00001;
   g_HB= adimat_g_mrdivide((g_tmp_expansion_f_00009), (tmp_expansion_f_00009), (g_tmp_expansion_f_00012), (tmp_expansion_f_00012));
   HB= tmp_expansion_f_00009/ tmp_expansion_f_00012; 
   
   %% Temporal loop (spatially discretized!!) vectorization!?? 
   %x(:,1)=xi;
   %y(:,1)=yi;
   xy_fronts{1}= [xi, yi]; 
   
   g_xy_fronts{1}= [g_zeros(size(xi)), g_zeros(size(yi))];
   for t= 2: 1: Nt+ 1% dependencia en a,b,c si RoS o! U o theta depenen del temps! 
      
      xy_fuel= round(xy_fronts{t- 1, 1}); 
      xy_fuel(isnan(xy_fuel))= 1; %ELIMINA NaNs NO se pq surten!! l'enviem a la cordanada (0,0) del RoS!!
      % if xy_fuel points out of the fuel plot assign RoS=0!!!
      %%ind=find(x(:,t-1)>ReF.XWorldLimits(2)|x(:,t-1)<ReF.XWorldLimits(1)|y(:,t-1)>ReF.YWorldLimits(2)|y(:,t-1)<ReF.YWorldLimits(1));
      if sum(sum(isnan(xy_fuel)))> 1
         fprintf('MyErr:%d NaN encountered!!!\n', numel(isnan(xy_fuel)))
      end
      g_tmp_RoS_00000= g_RoS(sub2ind(size(RoS), xy_fuel(: , 2), xy_fuel(: , 1)));
      tmp_RoS_00000= RoS(sub2ind(size(RoS), xy_fuel(: , 2), xy_fuel(: , 1)));
      g_RoSkk= g_tmp_RoS_00000;
      RoSkk= tmp_RoS_00000; % Correcte!
      g_tmp_expansion_f_00013= 0.5* g_RoSkk;
      tmp_expansion_f_00013= 0.5* RoSkk;
      g_tmp_expansion_f_00014= adimat_g_mrdivide2(1, g_HB, HB);
      tmp_expansion_f_00014= 1/ HB;
      g_tmp_expansion_f_00015= g_tmp_expansion_f_00014+ g_zeros(1);
      tmp_expansion_f_00015= 1+ tmp_expansion_f_00014;
      g_tmp_expansion_f_00016= g_tmp_expansion_f_00013.* tmp_expansion_f_00015+ tmp_expansion_f_00013.* g_tmp_expansion_f_00015;
      tmp_expansion_f_00016= tmp_expansion_f_00013.* tmp_expansion_f_00015;
      g_a= adimat_g_mrdivide(g_tmp_expansion_f_00016, tmp_expansion_f_00016, g_LB, LB);
      a= tmp_expansion_f_00016/ LB; 
      g_tmp_expansion_f_00017= adimat_g_mrdivide2(1, g_HB, HB);
      tmp_expansion_f_00017= 1/ HB;
      g_tmp_expansion_f_00018= g_tmp_expansion_f_00017+ g_zeros(1);
      tmp_expansion_f_00018= 1+ tmp_expansion_f_00017;
      g_tmp_expansion_f_00019= g_RoSkk.* tmp_expansion_f_00018+ RoSkk.* g_tmp_expansion_f_00018;
      tmp_expansion_f_00019= RoSkk.* tmp_expansion_f_00018;
      g_b= adimat_g_mrdivide1(g_tmp_expansion_f_00019, tmp_expansion_f_00019, 2);
      b= tmp_expansion_f_00019/ 2; 
      g_tmp_expansion_f_00020= (g_RoSkk.* HB- RoSkk.* g_HB)./ HB.^ 2;
      tmp_expansion_f_00020= RoSkk./ HB;
      g_c= g_b- g_tmp_expansion_f_00020;
      c= b- tmp_expansion_f_00020; 
      
      
      if flag_method== 1% FÓRMULA TEORICA- NO VA
         tmp_expansion_f_00074= flipud(xiyi); 
         % Update detected: xiyi= some_expression(xiyi,...)
         xiyi= tmp_expansion_f_00074;
         xRef= min(xiyi(: , 1)); 
         yRef= min(xiyi(: , 2)); 
         tmp_expansion_f_00021= xi- xRef;
         g_tmp_sin_00000= g_theta.* cos(theta);
         tmp_sin_00000= sin(theta);
         g_tmp_expansion_f_00022= tmp_expansion_f_00021.* g_tmp_sin_00000;
         tmp_expansion_f_00022= tmp_expansion_f_00021.* tmp_sin_00000;
         tmp_expansion_f_00023= yi- yRef;
         g_tmp_cos_00000= g_theta.* (-sin(theta));
         tmp_cos_00000= cos(theta);
         g_tmp_expansion_f_00024= tmp_expansion_f_00023.* g_tmp_cos_00000;
         tmp_expansion_f_00024= tmp_expansion_f_00023.* tmp_cos_00000;
         g_tmp_expansion_f_00025= g_tmp_expansion_f_00022+ g_tmp_expansion_f_00024;
         tmp_expansion_f_00025= tmp_expansion_f_00022+ tmp_expansion_f_00024;
         g_A= g_a.* tmp_expansion_f_00025+ a.* g_tmp_expansion_f_00025;
         A= a.* tmp_expansion_f_00025; %AQUI corregeixo referència
         tmp_expansion_f_00026= xi- xRef;
         tmp_expansion_f_00027= -tmp_expansion_f_00026;
         g_tmp_cos_00001= g_theta.* (-sin(theta));
         tmp_cos_00001= cos(theta);
         g_tmp_expansion_f_00028= tmp_expansion_f_00027.* g_tmp_cos_00001;
         tmp_expansion_f_00028= tmp_expansion_f_00027.* tmp_cos_00001;
         tmp_expansion_f_00029= yi- yRef;
         g_tmp_sin_00001= g_theta.* cos(theta);
         tmp_sin_00001= sin(theta);
         g_tmp_expansion_f_00030= tmp_expansion_f_00029.* g_tmp_sin_00001;
         tmp_expansion_f_00030= tmp_expansion_f_00029.* tmp_sin_00001;
         g_tmp_expansion_f_00031= g_tmp_expansion_f_00028+ g_tmp_expansion_f_00030;
         tmp_expansion_f_00031= tmp_expansion_f_00028+ tmp_expansion_f_00030;
         g_B= g_b.* tmp_expansion_f_00031+ b.* g_tmp_expansion_f_00031;
         B= b.* tmp_expansion_f_00031; 
         g_tmp_expansion_f_00032= 2.* A.^ (2- 1).* g_A;
         tmp_expansion_f_00032= A.^ 2;
         g_tmp_expansion_f_00033= 2.* B.^ (2- 1).* g_B;
         tmp_expansion_f_00033= B.^ 2;
         g_tmp_expansion_f_00034= g_tmp_expansion_f_00032+ g_tmp_expansion_f_00033;
         tmp_expansion_f_00034= tmp_expansion_f_00032+ tmp_expansion_f_00033;
         tmp_sqrt_00002= sqrt(tmp_expansion_f_00034);
         g_tmp_sqrt_00002= g_tmp_expansion_f_00034./ (2.* tmp_sqrt_00002);
         g_cos_phi= (g_A.* tmp_sqrt_00002- A.* g_tmp_sqrt_00002)./ tmp_sqrt_00002.^ 2;
         cos_phi= A./ tmp_sqrt_00002; 
         g_tmp_expansion_f_00035= 2.* A.^ (2- 1).* g_A;
         tmp_expansion_f_00035= A.^ 2;
         g_tmp_expansion_f_00036= 2.* B.^ (2- 1).* g_B;
         tmp_expansion_f_00036= B.^ 2;
         g_tmp_expansion_f_00037= g_tmp_expansion_f_00035+ g_tmp_expansion_f_00036;
         tmp_expansion_f_00037= tmp_expansion_f_00035+ tmp_expansion_f_00036;
         tmp_sqrt_00003= sqrt(tmp_expansion_f_00037);
         g_tmp_sqrt_00003= g_tmp_expansion_f_00037./ (2.* tmp_sqrt_00003);
         g_sin_phi= (g_B.* tmp_sqrt_00003- B.* g_tmp_sqrt_00003)./ tmp_sqrt_00003.^ 2;
         sin_phi= B./ tmp_sqrt_00003; 
         
         tmp_expansion_f_00075= x(: , t- 1)+ dt* (a.* cos(theta).* cos_phi+ b.* sin(theta).* sin_phi+ c.* sin(theta)); 
         % Update detected: x= some_expression(x,...)
         x(: , t)= tmp_expansion_f_00075;
         tmp_expansion_f_00076= y(: , t- 1)+ dt* (-a.* sin(theta).* cos_phi+ b.* cos(theta).* sin_phi+ c.* cos(theta)); 
         
         % Update detected: y= some_expression(y,...)
         y(: , t)= tmp_expansion_f_00076;
      elseif flag_method== 2%FÓRMULA CORRECTA!!!!
         tmp_expansion_f_00077= flipud(xiyi); 
         % Update detected: xiyi= some_expression(xiyi,...)
         xiyi= tmp_expansion_f_00077;
         xRef= min(xiyi(: , 1)); 
         yRef= min(xiyi(: , 2)); 
         tmp_expansion_f_00038= xi- xRef;
         g_tmp_sin_00002= g_theta.* cos(theta);
         tmp_sin_00002= sin(theta);
         g_tmp_expansion_f_00039= tmp_expansion_f_00038.* g_tmp_sin_00002;
         tmp_expansion_f_00039= tmp_expansion_f_00038.* tmp_sin_00002;
         tmp_expansion_f_00040= yi- yRef;
         g_tmp_cos_00002= g_theta.* (-sin(theta));
         tmp_cos_00002= cos(theta);
         g_tmp_expansion_f_00041= tmp_expansion_f_00040.* g_tmp_cos_00002;
         tmp_expansion_f_00041= tmp_expansion_f_00040.* tmp_cos_00002;
         g_tmp_expansion_f_00042= g_tmp_expansion_f_00039+ g_tmp_expansion_f_00041;
         tmp_expansion_f_00042= tmp_expansion_f_00039+ tmp_expansion_f_00041;
         g_A= g_a.* tmp_expansion_f_00042+ a.* g_tmp_expansion_f_00042;
         A= a.* tmp_expansion_f_00042; %AQUI corregeixo referència
         tmp_expansion_f_00043= xi- xRef;
         tmp_expansion_f_00044= -tmp_expansion_f_00043;
         g_tmp_cos_00003= g_theta.* (-sin(theta));
         tmp_cos_00003= cos(theta);
         g_tmp_expansion_f_00045= tmp_expansion_f_00044.* g_tmp_cos_00003;
         tmp_expansion_f_00045= tmp_expansion_f_00044.* tmp_cos_00003;
         tmp_expansion_f_00046= yi- yRef;
         g_tmp_sin_00003= g_theta.* cos(theta);
         tmp_sin_00003= sin(theta);
         g_tmp_expansion_f_00047= tmp_expansion_f_00046.* g_tmp_sin_00003;
         tmp_expansion_f_00047= tmp_expansion_f_00046.* tmp_sin_00003;
         g_tmp_expansion_f_00048= g_tmp_expansion_f_00045+ g_tmp_expansion_f_00047;
         tmp_expansion_f_00048= tmp_expansion_f_00045+ tmp_expansion_f_00047;
         g_B= g_b.* tmp_expansion_f_00048+ b.* g_tmp_expansion_f_00048;
         B= b.* tmp_expansion_f_00048; 
         g_tmp_expansion_f_00049= 2.* A.^ (2- 1).* g_A;
         tmp_expansion_f_00049= A.^ 2;
         g_tmp_expansion_f_00050= 2.* B.^ (2- 1).* g_B;
         tmp_expansion_f_00050= B.^ 2;
         g_tmp_expansion_f_00051= g_tmp_expansion_f_00049+ g_tmp_expansion_f_00050;
         tmp_expansion_f_00051= tmp_expansion_f_00049+ tmp_expansion_f_00050;
         tmp_sqrt_00004= sqrt(tmp_expansion_f_00051);
         g_tmp_sqrt_00004= g_tmp_expansion_f_00051./ (2.* tmp_sqrt_00004);
         g_cos_phi= (g_A.* tmp_sqrt_00004- A.* g_tmp_sqrt_00004)./ tmp_sqrt_00004.^ 2;
         cos_phi= A./ tmp_sqrt_00004; 
         g_tmp_expansion_f_00052= 2.* A.^ (2- 1).* g_A;
         tmp_expansion_f_00052= A.^ 2;
         g_tmp_expansion_f_00053= 2.* B.^ (2- 1).* g_B;
         tmp_expansion_f_00053= B.^ 2;
         g_tmp_expansion_f_00054= g_tmp_expansion_f_00052+ g_tmp_expansion_f_00053;
         tmp_expansion_f_00054= tmp_expansion_f_00052+ tmp_expansion_f_00053;
         tmp_sqrt_00005= sqrt(tmp_expansion_f_00054);
         g_tmp_sqrt_00005= g_tmp_expansion_f_00054./ (2.* tmp_sqrt_00005);
         g_sin_phi= (g_B.* tmp_sqrt_00005- B.* g_tmp_sqrt_00005)./ tmp_sqrt_00005.^ 2;
         sin_phi= B./ tmp_sqrt_00005; 
         
         g_tmp_xy_fronts_00000= g_xy_fronts{t}(: , 1);
         tmp_xy_fronts_00000= xy_fronts{t}(: , 1);
         g_tmp_sin_00004= g_theta.* cos(theta);
         tmp_sin_00004= sin(theta);
         g_tmp_expansion_f_00055= g_a.* tmp_sin_00004.* cos_phi+ a.* g_tmp_sin_00004.* cos_phi+ a.* tmp_sin_00004.* g_cos_phi;
         tmp_expansion_f_00055= a.* tmp_sin_00004.* cos_phi;
         g_tmp_cos_00004= g_theta.* (-sin(theta));
         tmp_cos_00004= cos(theta);
         g_tmp_expansion_f_00056= g_b.* tmp_cos_00004.* sin_phi+ b.* g_tmp_cos_00004.* sin_phi+ b.* tmp_cos_00004.* g_sin_phi;
         tmp_expansion_f_00056= b.* tmp_cos_00004.* sin_phi;
         g_tmp_cos_00005= g_theta.* (-sin(theta));
         tmp_cos_00005= cos(theta);
         g_tmp_expansion_f_00057= g_c.* tmp_cos_00005+ c.* g_tmp_cos_00005;
         tmp_expansion_f_00057= c.* tmp_cos_00005;
         g_tmp_expansion_f_00058= g_tmp_expansion_f_00055- g_tmp_expansion_f_00056+ g_tmp_expansion_f_00057;
         tmp_expansion_f_00058= tmp_expansion_f_00055- tmp_expansion_f_00056+ tmp_expansion_f_00057;
         g_tmp_expansion_f_00059= dt* g_tmp_expansion_f_00058;
         tmp_expansion_f_00059= dt* tmp_expansion_f_00058;
         g_tmp_expansion_f_00060= g_tmp_xy_fronts_00000+ g_tmp_expansion_f_00059;
         tmp_expansion_f_00060= tmp_xy_fronts_00000+ tmp_expansion_f_00059;
         tmp_expansion_f_00061= t- 1;
         g_tmp_xy_fronts_00001= g_xy_fronts{tmp_expansion_f_00061, 1}(: , 2);
         tmp_xy_fronts_00001= xy_fronts{tmp_expansion_f_00061, 1}(: , 2);
         g_tmp_cos_00006= g_theta.* (-sin(theta));
         tmp_cos_00006= cos(theta);
         g_tmp_expansion_f_00062= g_a.* tmp_cos_00006.* cos_phi+ a.* g_tmp_cos_00006.* cos_phi+ a.* tmp_cos_00006.* g_cos_phi;
         tmp_expansion_f_00062= a.* tmp_cos_00006.* cos_phi;
         g_tmp_sin_00005= g_theta.* cos(theta);
         tmp_sin_00005= sin(theta);
         g_tmp_expansion_f_00063= g_b.* tmp_sin_00005.* sin_phi+ b.* g_tmp_sin_00005.* sin_phi+ b.* tmp_sin_00005.* g_sin_phi;
         tmp_expansion_f_00063= b.* tmp_sin_00005.* sin_phi;
         g_tmp_sin_00006= g_theta.* cos(theta);
         tmp_sin_00006= sin(theta);
         g_tmp_expansion_f_00064= g_c.* tmp_sin_00006+ c.* g_tmp_sin_00006;
         tmp_expansion_f_00064= c.* tmp_sin_00006;
         g_tmp_expansion_f_00065= g_tmp_expansion_f_00062+ g_tmp_expansion_f_00063+ g_tmp_expansion_f_00064;
         tmp_expansion_f_00065= tmp_expansion_f_00062+ tmp_expansion_f_00063+ tmp_expansion_f_00064;
         g_tmp_expansion_f_00066= dt* g_tmp_expansion_f_00065;
         tmp_expansion_f_00066= dt* tmp_expansion_f_00065;
         g_tmp_expansion_f_00067= g_tmp_xy_fronts_00001+ g_tmp_expansion_f_00066;
         tmp_expansion_f_00067= tmp_xy_fronts_00001+ tmp_expansion_f_00066;
         g_xy_fronts{t, 1}= [g_tmp_expansion_f_00060, g_tmp_expansion_f_00067];
         xy_fronts{t, 1}= [tmp_expansion_f_00060, tmp_expansion_f_00067]; 
         %xy_fronts{t,1}=xy_fronts{t-1,1}+dt*(a.*sin(theta).*cos_phi-b.*cos(theta).*sin_phi+c.*cos(theta));
         %xy_fronts{t,2}=xy_fronts{t-1,2}+dt*(a.*cos(theta).*cos_phi+b.*sin(theta).*sin_phi+c.*sin(theta));
         
      else 
         % FÓRMULA ORIGINAL 1990 INTEGRADA PER CENTRED DIFERENCES
         tmp_expansion_f_00068= pi/ 2;
         g_theta_cor= g_theta+ g_zeros(size(tmp_expansion_f_00068));
         theta_cor= theta- tmp_expansion_f_00068; %les meves equacions tene un desfasament que cal corregir!! 
         tmp_expansion_f_00069= t- 1;
         g_tmp_xy_fronts_00002= g_xy_fronts{tmp_expansion_f_00069, 1}(: , 1);
         tmp_xy_fronts_00002= xy_fronts{tmp_expansion_f_00069, 1}(: , 1);
         tmp_expansion_f_00070= t- 1;
         g_tmp_xy_fronts_00003= g_xy_fronts{tmp_expansion_f_00070, 1}(: , 2);
         tmp_xy_fronts_00003= xy_fronts{tmp_expansion_f_00070, 1}(: , 2);
         [g_xy_fronts{t, 1}, xy_fronts{t, 1}]= g_huygns_integration(g_tmp_xy_fronts_00002, tmp_xy_fronts_00002, g_tmp_xy_fronts_00003, tmp_xy_fronts_00003, g_a, a, g_b, b, g_c, c, g_theta_cor, theta_cor, dt); 
         
         % regridding & loop clipping! NO SÉ QUÈ FER ABANS!!! 
         % looks nicer 1st REGRID +CLIPP (lasts litle longer) CHECK!!! -> TRUE
         
         %%%%%[xy_fronts{t,1}]=regridding(xy_fronts{t,1}(:,1),xy_fronts{t,1}(:,2));
         %    plot (xy_fronts{t,1},xy_fronts{t,2}, '-+r')
         g_tmp_xy_fronts_00004= g_xy_fronts{t, 1}(: , 1);
         tmp_xy_fronts_00004= xy_fronts{t, 1}(: , 1);
         g_tmp_xy_fronts_00005= g_xy_fronts{t, 1}(: , 2);
         tmp_xy_fronts_00005= xy_fronts{t, 1}(: , 2);
         [g_xy_fronts{t, 1}, xy_fronts{t, 1}]= g_loop_clipping(g_tmp_xy_fronts_00004, tmp_xy_fronts_00004, g_tmp_xy_fronts_00005, tmp_xy_fronts_00005); 
         g_tmp_xy_fronts_00006= g_xy_fronts{t, 1}(: , 1);
         tmp_xy_fronts_00006= xy_fronts{t, 1}(: , 1);
         g_tmp_xy_fronts_00007= g_xy_fronts{t, 1}(: , 2);
         tmp_xy_fronts_00007= xy_fronts{t, 1}(: , 2);
         [g_xy_fronts{t, 1}, xy_fronts{t, 1}]= g_regridding(g_tmp_xy_fronts_00006, tmp_xy_fronts_00006, g_tmp_xy_fronts_00007, tmp_xy_fronts_00007); 
         g_tmp_xy_fronts_00008= g_xy_fronts{t, 1}(: , 1);
         tmp_xy_fronts_00008= xy_fronts{t, 1}(: , 1);
         g_tmp_xy_fronts_00009= g_xy_fronts{t, 1}(: , 2);
         tmp_xy_fronts_00009= xy_fronts{t, 1}(: , 2);
         [g_xy_fronts{t, 1}, xy_fronts{t, 1}]= g_loop_clipping(g_tmp_xy_fronts_00008, tmp_xy_fronts_00008, g_tmp_xy_fronts_00009, tmp_xy_fronts_00009); 
         
         
         
         %CLOSE PERIMETER
         g_tmp_xy_fronts_00010= g_xy_fronts{t, 1};
         tmp_xy_fronts_00010= xy_fronts{t, 1};
         g_tmp_xy_fronts_00011= g_xy_fronts{t, 1}(1, : );
         tmp_xy_fronts_00011= xy_fronts{t, 1}(1, : );
         g_xy_fronts{t, 1}= [g_tmp_xy_fronts_00010;
            g_tmp_xy_fronts_00011];
         xy_fronts{t, 1}= [tmp_xy_fronts_00010;
            tmp_xy_fronts_00011]; 
         
         
         % DEGRIDDING (twice necessary)?¿ why?
         %    fprintf('DEGRID START. Time %d \n',t)
         % !!!!![xy_fronts{t,1},xy_fronts{t,2}]=degridding(xy_fronts{t,1},xy_fronts{t,2});
         %    disp('one done')
         %[xy_fronts{t,1},xy_fronts{t,2}]=degridding(xy_fronts{t,1},xy_fronts{t,2});
         
         % RECLOSE PERIMETER IF DEGRIDING HAS OPEN IT
         if xy_fronts{t, 1}(1, : )~= xy_fronts{t, 1}(end, : )
            g_tmp_xy_fronts_00012= g_xy_fronts{t, 1}(1, : );
            tmp_xy_fronts_00012= xy_fronts{t, 1}(1, : );
            g_xy_fronts{t, 1}(end+ 1, : )= g_tmp_xy_fronts_00012;
            xy_fronts{t, 1}(end+ 1, : )= tmp_xy_fronts_00012; 
         end
         % SMOOTHING Y (only)
         % % %         if flag_smooth==1
         % % %             [xy_fronts{t,2}]=smooth(xy_fronts{t,1},xy_fronts{t,2},3);
         % % %         end
         
         % %         hold on
         % %         %plot (xy_fronts{1,1},xy_fronts{1,2}, '-xr')
         % %         plot (xy_fronts{t,1},xy_fronts{t,2}, '--x', 'color',color_map(t,:))
         % %         plot (xy_fronts{t,1},xy_fronts{t,2}, '--xg')
      end
   end
   
   %% PLOTTING
   %figure
   %grid minor
   % % % % % % hold on
   % % % % % % for t=2:m
   % % % % % %     if flag_method==3
   % % % % % %     %plot (xy_fronts{t,1}, xy_fronts{t,2}, '--xk')
   % % % % % %     plot (xy_fronts{t,1}, xy_fronts{t,2}, '--x', 'color', color_map(t,:))
   % % % % % %     else
   % % % % % %     plot (xy_fronts{t,1}, xy_fronts{t,2}, '--xm')
   % % % % % %     end
   % % % % % % end
   % % % % % % hold on
   % % % % % % plot (xy_fronts{1,1}, xy_fronts{1,2}, '-xr')
   
   %for i=1:n
   %  plot(x(i,:), y(i,:), 'g')  
   %end
   % plot(x(1,:), y(1,:), 'r')  
   % plot(x(2,:), y(2,:), 'r')  
end

function [g_xyout, xyout]= g_huygns_integration(g_x, x, g_y, y, g_a, a, g_b, b, g_c, c, g_theta, theta, dt)
   %implemented function from Richards1990 (pag 1168)
   % IMPORTANT! el primer i últim valor no poden estar DUPLICATS!
   % integrates using Euler and Predictor-Corrector methods along dt
   
   %Initial Checks
   if numel(a)> 1&& numel(a)~= numel(x)
      error('MyErr:huygns_integration-> length a~=x')
   end
   
   % Preditor
   [g_Pdx, Pdx, g_Pdy, Pdy]= g_F(g_x, x, g_y, y, g_a, a, g_b, b, g_c, c, g_theta, theta); 
   g_tmp_huygns_integration_00000= dt* g_Pdx;
   tmp_huygns_integration_00000= dt* Pdx;
   g_Px= g_x+ g_tmp_huygns_integration_00000;
   Px= x+ tmp_huygns_integration_00000; 
   g_tmp_huygns_integration_00001= dt* g_Pdy;
   tmp_huygns_integration_00001= dt* Pdy;
   g_Py= g_y+ g_tmp_huygns_integration_00001;
   Py= y+ tmp_huygns_integration_00001; 
   
   %Corrector
   [g_Cdx, Cdx, g_Cdy, Cdy]= g_F(g_Px, Px, g_Py, Py, g_a, a, g_b, b, g_c, c, g_theta, theta); 
   g_tmp_huygns_integration_00002= g_Pdx+ g_Cdx;
   tmp_huygns_integration_00002= Pdx+ Cdx;
   g_tmp_huygns_integration_00003= 0.5* dt* g_tmp_huygns_integration_00002;
   tmp_huygns_integration_00003= 0.5* dt* tmp_huygns_integration_00002;
   g_xout= g_x+ g_tmp_huygns_integration_00003;
   xout= x+ tmp_huygns_integration_00003; 
   g_tmp_huygns_integration_00004= g_Pdy+ g_Cdy;
   tmp_huygns_integration_00004= Pdy+ Cdy;
   g_tmp_huygns_integration_00005= 0.5* dt* g_tmp_huygns_integration_00004;
   tmp_huygns_integration_00005= 0.5* dt* tmp_huygns_integration_00004;
   g_yout= g_y+ g_tmp_huygns_integration_00005;
   yout= y+ tmp_huygns_integration_00005; 
   
   % Correct for NaNs (not propagation). Copy last point
   NaNxy= isnan(xout); 
   g_tmp_x_00000= g_x(NaNxy);
   tmp_x_00000= x(NaNxy);
   g_xout(NaNxy)= g_tmp_x_00000;
   xout(NaNxy)= tmp_x_00000; 
   g_tmp_y_00000= g_y(NaNxy);
   tmp_y_00000= y(NaNxy);
   g_yout(NaNxy)= g_tmp_y_00000;
   yout(NaNxy)= tmp_y_00000; 
   g_xyout= [g_xout, g_yout];
   xyout= [xout, yout]; 
end
% **************************************************************************
%                        LOOP CLIPPING SCHEME
% **************************************************************************
% Algorithm:
% -Check for segment intersections within the same front
% -Convert intersaction into a point an place it correctly
% -Remove loop points
% WARNING: combnk(v,k) might be costly!
% INPUTS
% x,y           curve x,y colum vectors
%
% OUTPUTS
%
% xnew,ynew     curve without loops
function [g_xy_no_loop, xy_no_loop]= g_loop_clipping(g_x, x, g_y, y)
   % create all pairs combinations to check intersection
   %adjacent segments cannot cross
   % NO ho sé fer sense loop!!
   g_tmp_x_00001= g_x(2: end);
   tmp_x_00001= x(2: end);
   g_tmp_y_00001= g_y(2: end);
   tmp_y_00001= y(2: end);
   g_tmp_x_00002= g_x(1);
   tmp_x_00002= x(1);
   g_tmp_y_00002= g_y(1);
   tmp_y_00002= y(1);
   g_tmp_loop_clipping_00000= [g_tmp_x_00001, g_tmp_y_00001;
      g_tmp_x_00002, g_tmp_y_00002];
   tmp_loop_clipping_00000= [tmp_x_00001, tmp_y_00001;
      tmp_x_00002, tmp_y_00002];
   g_edge_xy= [g_x, g_y, g_tmp_loop_clipping_00000];
   edge_xy= [x, y, tmp_loop_clipping_00000]; 
   g_xy_no_loop= [g_x, g_y];
   xy_no_loop= [x, y]; 
   % ALGORITHM to check for intersections utilitzant C = combnk(v,k) !!
   c= combnk(1: size(x, 1), 2); 
   %c = flipud(combnk(1:length(x),2)); %creates de combinatorial adjacent matrix! ATENCIÓ!! PILLA TEMPS!
   g_tmp_edge_xy_00000= g_edge_xy(c(: , 1), : );
   tmp_edge_xy_00000= edge_xy(c(: , 1), : );
   g_tmp_edge_xy_00001= g_edge_xy(c(: , 2), : );
   tmp_edge_xy_00001= edge_xy(c(: , 2), : );
   g_comb_xy= [g_tmp_edge_xy_00000, g_tmp_edge_xy_00001];
   comb_xy= [tmp_edge_xy_00000, tmp_edge_xy_00001]; 
   tmp_loop_clipping_00001= 1: 4;
   g_tmp_comb_xy_00000= g_comb_xy(: , tmp_loop_clipping_00001);
   tmp_comb_xy_00000= comb_xy(: , tmp_loop_clipping_00001);
   tmp_loop_clipping_00002= 5: 8;
   g_tmp_comb_xy_00001= g_comb_xy(: , tmp_loop_clipping_00002);
   tmp_comb_xy_00001= comb_xy(: , tmp_loop_clipping_00002);
   [g_xy_inter, xy_inter, int_adj]= g_intersect2segments(g_tmp_comb_xy_00000, tmp_comb_xy_00000, g_tmp_comb_xy_00001, tmp_comb_xy_00001); 
   intersected_edges= c(int_adj, : ); 
   %
   %%hold on; plot(xy_inter(:,1),xy_inter(:,2),'r*') % TEMPORAL PLOT
   %%
   g_xy_no_loop(intersected_edges(: , 1)+ 1, : )= g_xy_inter;
   xy_no_loop(intersected_edges(: , 1)+ 1, : )= xy_inter; % Add intersection points (substitute first point in the loop)
   del_ind= []; 
   % number of intersections
   for i= 1: size(intersected_edges, 1)
      tmp_loop_clipping_00003= [del_ind, intersected_edges(i, 1)+ 2: intersected_edges(i, 2)]; 
      % Update detected: del_ind= some_expression(del_ind,...)
      del_ind= tmp_loop_clipping_00003;
   end
   xy_no_loop(del_ind, : )= []; 
   g_xy_no_loop(del_ind, : )= [];
   g_tmp_xy_no_loop_00000= g_xy_no_loop(: , 1);
   tmp_xy_no_loop_00000= xy_no_loop(: , 1);
   g_x_no_loop= g_tmp_xy_no_loop_00000;
   x_no_loop= tmp_xy_no_loop_00000; 
   g_tmp_xy_no_loop_00001= g_xy_no_loop(: , 2);
   tmp_xy_no_loop_00001= xy_no_loop(: , 2);
   g_y_no_loop= g_tmp_xy_no_loop_00001;
   y_no_loop= tmp_xy_no_loop_00001; 
   %    plot(xy_no_loop(:,1),xy_no_loop(:,2),'--g+')
   % Alternative changing cols
   %    comb_xy=[x(c) y(c)];
   %    comb_xy(:,[2,4])=comb_xy(:,[4,2]);
   g_xy_no_loop= [g_x_no_loop, g_y_no_loop];
   xy_no_loop= [x_no_loop, y_no_loop]; 
end

% Version 2: Vectorized
% **************************************************************************
%                        REGRIDING SCHEME (Oriol Version)
% **************************************************************************
%     l1 and l2 are the lengths of line segments where v1, v2, v2r and v3 are vectors of 3 conjoining line segments.  The angle between
%     v1/v2 and v2r/v3 is determined using the dot product.  Once the angles, omega1 and omega2 have been determined they are compared to a preset
%     criterion.
%     The miminum of the two angles is determined and if it is less than approximately 90 degrees than  The newx and newy points are inserted into the
%     previous x and y array and % the process is repeated until the onditions are satisfied and the curve is adequately discretized.
%     the following algorithms is necessary when the fire front is making its way around a boundary and the curve produces
%
%     ADD DEGRID capabilities in else case!
%     TRESHOLDS in LINE 42 & 58!!!
function [g_newxy, newxy]= g_regridding(g_x, x, g_y, y)
   %T= 1;% Recgridding threshold (Richards 1)
   T= pi/ 10; % the smaller T the smoother the front!
   norm_min= 1; % [m] min distance between nodes TO DEGRID!
   % Sensiblitat actual >pi/4
   
   % create all vectors
   xy_1= [x, y]; 
   xy_2= [x(2: end), y(2: end);
      x(1), y(1)]; 
   xy_3= [x(3: end), y(3: end);
      x(1: 2), y(1: 2)]; 
   
   v_1= diff(xy_1); 
   v_2= diff(xy_2); 
   v_3= diff(xy_3); 
   
   N_1= sqrt(v_1(: , 1).^ 2+ v_1(: , 2).^ 2); 
   N_2= sqrt(v_2(: , 1).^ 2+ v_2(: , 2).^ 2); 
   N_3= sqrt(v_3(: , 1).^ 2+ v_3(: , 2).^ 2); 
   
   cosomega1= dot(v_1, v_2, 2)./ (N_1.* N_2); 
   cosomega2= dot(v_2, v_3, 2)./ (N_2.* N_3); 
   
   omega1= acos(cosomega1); %in radians
   omega2= acos(cosomega2); 
   
   g_newx= g_x;
   newx= x; 
   g_newy= g_y;
   newy= y; 
   j= 0; 
   %%% old regridd % % % % degrid=[];
   delete_points_ind= []; 
   tmp_regridding_00000= size(cosomega1, 1)- 1;
   for i= 1: tmp_regridding_00000
      [c, ind]= max([omega1(i), omega2(i)]); 
      %if c >(T/180*pi) %as Sara McAlister
      if c> T
         if ind== 1%disp('dins1')
            g_tmp_x_00003= g_x(i);
            tmp_x_00003= x(i);
            tmp_regridding_00001= i+ 1;
            g_tmp_x_00004= g_x(tmp_regridding_00001);
            tmp_x_00004= x(tmp_regridding_00001);
            g_tmp_x_00005= g_x(i);
            tmp_x_00005= x(i);
            g_tmp_regridding_00002= g_tmp_x_00004- g_tmp_x_00005;
            tmp_regridding_00002= tmp_x_00004- tmp_x_00005;
            g_tmp_regridding_00003= 0.5* g_tmp_regridding_00002;
            tmp_regridding_00003= 0.5* tmp_regridding_00002;
            g_xt= g_tmp_x_00003+ g_tmp_regridding_00003;
            xt= tmp_x_00003+ tmp_regridding_00003; % point in the midle of the segment
            g_tmp_y_00003= g_y(i);
            tmp_y_00003= y(i);
            tmp_regridding_00004= i+ 1;
            g_tmp_y_00004= g_y(tmp_regridding_00004);
            tmp_y_00004= y(tmp_regridding_00004);
            g_tmp_y_00005= g_y(i);
            tmp_y_00005= y(i);
            g_tmp_regridding_00005= g_tmp_y_00004- g_tmp_y_00005;
            tmp_regridding_00005= tmp_y_00004- tmp_y_00005;
            g_tmp_regridding_00006= 0.5* g_tmp_regridding_00005;
            tmp_regridding_00006= 0.5* tmp_regridding_00005;
            g_yt= g_tmp_y_00003+ g_tmp_regridding_00006;
            yt= tmp_y_00003+ tmp_regridding_00006; 
            tmp_regridding_00007= i+ j;
            tmp_regridding_00008= 1: tmp_regridding_00007;
            g_tmp_newx_00000= g_newx(tmp_regridding_00008);
            tmp_newx_00000= newx(tmp_regridding_00008);
            g_tmp_x_00006= g_x(i+ 1: end);
            tmp_x_00006= x(i+ 1: end);
            g_newx= [g_tmp_newx_00000;
               g_xt;
               g_tmp_x_00006];
            newx= [tmp_newx_00000;
               xt;
               tmp_x_00006]; 
            tmp_regridding_00009= i+ j;
            tmp_regridding_00010= 1: tmp_regridding_00009;
            g_tmp_newy_00000= g_newy(tmp_regridding_00010);
            tmp_newy_00000= newy(tmp_regridding_00010);
            g_tmp_y_00006= g_y(i+ 1: end);
            tmp_y_00006= y(i+ 1: end);
            g_newy= [g_tmp_newy_00000;
               g_yt;
               g_tmp_y_00006];
            newy= [tmp_newy_00000;
               yt;
               tmp_y_00006]; 
         else %second angle
            %disp('dins2')
            tmp_regridding_00011= i+ 1;
            g_tmp_x_00007= g_x(tmp_regridding_00011);
            tmp_x_00007= x(tmp_regridding_00011);
            tmp_regridding_00012= i+ 2;
            g_tmp_x_00008= g_x(tmp_regridding_00012);
            tmp_x_00008= x(tmp_regridding_00012);
            tmp_regridding_00013= i+ 1;
            g_tmp_x_00009= g_x(tmp_regridding_00013);
            tmp_x_00009= x(tmp_regridding_00013);
            g_tmp_regridding_00014= g_tmp_x_00008- g_tmp_x_00009;
            tmp_regridding_00014= tmp_x_00008- tmp_x_00009;
            g_tmp_regridding_00015= 0.5* g_tmp_regridding_00014;
            tmp_regridding_00015= 0.5* tmp_regridding_00014;
            g_xt= g_tmp_x_00007+ g_tmp_regridding_00015;
            xt= tmp_x_00007+ tmp_regridding_00015; 
            tmp_regridding_00016= i+ 1;
            g_tmp_y_00007= g_y(tmp_regridding_00016);
            tmp_y_00007= y(tmp_regridding_00016);
            tmp_regridding_00017= i+ 2;
            g_tmp_y_00008= g_y(tmp_regridding_00017);
            tmp_y_00008= y(tmp_regridding_00017);
            tmp_regridding_00018= i+ 1;
            g_tmp_y_00009= g_y(tmp_regridding_00018);
            tmp_y_00009= y(tmp_regridding_00018);
            g_tmp_regridding_00019= g_tmp_y_00008- g_tmp_y_00009;
            tmp_regridding_00019= tmp_y_00008- tmp_y_00009;
            g_tmp_regridding_00020= 0.5* g_tmp_regridding_00019;
            tmp_regridding_00020= 0.5* tmp_regridding_00019;
            g_yt= g_tmp_y_00007+ g_tmp_regridding_00020;
            yt= tmp_y_00007+ tmp_regridding_00020; 
            tmp_regridding_00021= i+ 1+ j;
            tmp_regridding_00022= 1: tmp_regridding_00021;
            g_tmp_newx_00001= g_newx(tmp_regridding_00022);
            tmp_newx_00001= newx(tmp_regridding_00022);
            g_tmp_x_00010= g_x(i+ 2: end);
            tmp_x_00010= x(i+ 2: end);
            g_newx= [g_tmp_newx_00001;
               g_xt;
               g_tmp_x_00010];
            newx= [tmp_newx_00001;
               xt;
               tmp_x_00010]; 
            tmp_regridding_00023= i+ 1+ j;
            tmp_regridding_00024= 1: tmp_regridding_00023;
            g_tmp_newy_00001= g_newy(tmp_regridding_00024);
            tmp_newy_00001= newy(tmp_regridding_00024);
            g_tmp_y_00010= g_y(i+ 2: end);
            tmp_y_00010= y(i+ 2: end);
            g_newy= [g_tmp_newy_00001;
               g_yt;
               g_tmp_y_00010];
            newy= [tmp_newy_00001;
               yt;
               tmp_y_00010]; 
         end
         tmp_regridding_00025= j+ 1; 
         % DEGRID of points with distance less than norm_min and flats
         % Update detected: j= some_expression(j,...)
         j= tmp_regridding_00025;
      elseif N_1(i)< norm_min%newx(i+j+1)=[];
         %newy(i+j+1)=[];
         tmp_regridding_00026= [delete_points_ind, (i+ j+ 1)]; 
         % Update detected: delete_points_ind= some_expression(delete_points_ind,...)
         delete_points_ind= tmp_regridding_00026;
         tmp_regridding_00027= j- 1; 
         %%% old regridd % % % %         degrid=[degrid;newx(i+j+1),newy(i+j+1)];
         % Update detected: j= some_expression(j,...)
         j= tmp_regridding_00027;
      end
      tmp_regridding_00000= size(cosomega1, 1)- 1;
   end
   %% OLD
   %remove DEGRIDDING points PQ NO VA SENSE AIXÖ? PQ ES GENEREN TANTS PUNTS?
   %%% old regridd % % % % if ~isempty(degrid)
   %%% old regridd % % % %     disp('dins')
   %%% old regridd % % % %     ind_logic=ismember([newx newy],degrid ,'rows');
   %%% old regridd % % % %     % què tal fer anar Unique??
   %%% old regridd % % % %     % unique(A,'rows'
   %%% old regridd % % % %     ind=1:(size(newx,1));
   %%% old regridd % % % %     index=ind(ind_logic);
   %%% old regridd % % % %     %[newx(index) newy(index)]
   %%% old regridd % % % %     %disp('degridded')
   %%% old regridd % % % %     newx(index)=[];
   %%% old regridd % % % %     newy(index)=[];
   %%% old regridd % % % %
   %%% old regridd % % % % end
   %% end OLD
   newx(delete_points_ind)= []; 
   g_newx(delete_points_ind)= [];
   newy(delete_points_ind)= []; 
   g_newy(delete_points_ind)= [];
   g_newxy= [g_newx, g_newy];
   newxy= [newx, newy]; 
end











function [g_dx, dx, g_dy, dy]= g_F(g_x, x, g_y, y, g_a, a, g_b, b, g_c, c, g_theta, theta)
   %implemented function from Richards1990 (pag 1168)
   % centered diferences
   g_tmp_x_00011= g_x(2: end);
   tmp_x_00011= x(2: end);
   g_tmp_x_00012= g_x(1);
   tmp_x_00012= x(1);
   g_tmp_F_00000= [g_tmp_x_00011;
      g_tmp_x_00012];
   tmp_F_00000= [tmp_x_00011;
      tmp_x_00012];
   g_tmp_x_00013= g_x(end);
   tmp_x_00013= x(end);
   g_tmp_x_00014= g_x(1: end- 1);
   tmp_x_00014= x(1: end- 1);
   g_tmp_F_00001= [g_tmp_x_00013;
      g_tmp_x_00014];
   tmp_F_00001= [tmp_x_00013;
      tmp_x_00014];
   g_tmp_F_00002= g_tmp_F_00000- g_tmp_F_00001;
   tmp_F_00002= tmp_F_00000- tmp_F_00001;
   g_dxs= g_tmp_F_00002./ 2;
   dxs= tmp_F_00002./ 2; 
   g_tmp_y_00011= g_y(2: end);
   tmp_y_00011= y(2: end);
   g_tmp_y_00012= g_y(1);
   tmp_y_00012= y(1);
   g_tmp_F_00003= [g_tmp_y_00011;
      g_tmp_y_00012];
   tmp_F_00003= [tmp_y_00011;
      tmp_y_00012];
   g_tmp_y_00013= g_y(end);
   tmp_y_00013= y(end);
   g_tmp_y_00014= g_y(1: end- 1);
   tmp_y_00014= y(1: end- 1);
   g_tmp_F_00004= [g_tmp_y_00013;
      g_tmp_y_00014];
   tmp_F_00004= [tmp_y_00013;
      tmp_y_00014];
   g_tmp_F_00005= g_tmp_F_00003- g_tmp_F_00004;
   tmp_F_00005= tmp_F_00003- tmp_F_00004;
   g_dys= g_tmp_F_00005./ 2;
   dys= tmp_F_00005./ 2; 
   
   g_tmp_sin_00007= g_theta.* cos(theta);
   tmp_sin_00007= sin(theta);
   g_tmp_F_00006= g_dxs.* tmp_sin_00007+ dxs.* g_tmp_sin_00007;
   tmp_F_00006= dxs.* tmp_sin_00007;
   g_tmp_cos_00007= g_theta.* (-sin(theta));
   tmp_cos_00007= cos(theta);
   g_tmp_F_00007= g_dys.* tmp_cos_00007+ dys.* g_tmp_cos_00007;
   tmp_F_00007= dys.* tmp_cos_00007;
   g_P1= g_tmp_F_00006+ g_tmp_F_00007;
   P1= tmp_F_00006+ tmp_F_00007; 
   g_tmp_cos_00008= g_theta.* (-sin(theta));
   tmp_cos_00008= cos(theta);
   g_tmp_F_00008= g_dxs.* tmp_cos_00008+ dxs.* g_tmp_cos_00008;
   tmp_F_00008= dxs.* tmp_cos_00008;
   g_tmp_sin_00008= g_theta.* cos(theta);
   tmp_sin_00008= sin(theta);
   g_tmp_F_00009= g_dys.* tmp_sin_00008+ dys.* g_tmp_sin_00008;
   tmp_F_00009= dys.* tmp_sin_00008;
   g_P2= g_tmp_F_00008- g_tmp_F_00009;
   P2= tmp_F_00008- tmp_F_00009; 
   g_tmp_F_00010= 2.* b.^ (2- 1).* g_b;
   tmp_F_00010= b.^ 2;
   g_tmp_cos_00009= g_theta.* (-sin(theta));
   tmp_cos_00009= cos(theta);
   g_tmp_F_00011= g_dxs.* tmp_cos_00009+ dxs.* g_tmp_cos_00009;
   tmp_F_00011= dxs.* tmp_cos_00009;
   g_tmp_sin_00009= g_theta.* cos(theta);
   tmp_sin_00009= sin(theta);
   g_tmp_F_00012= g_dys.* tmp_sin_00009+ dys.* g_tmp_sin_00009;
   tmp_F_00012= dys.* tmp_sin_00009;
   g_tmp_F_00013= g_tmp_F_00011- g_tmp_F_00012;
   tmp_F_00013= tmp_F_00011- tmp_F_00012;
   g_tmp_F_00014= 2.* tmp_F_00013.^ (2- 1).* g_tmp_F_00013;
   tmp_F_00014= tmp_F_00013.^ 2;
   g_tmp_F_00015= g_tmp_F_00010.* tmp_F_00014+ tmp_F_00010.* g_tmp_F_00014;
   tmp_F_00015= tmp_F_00010.* tmp_F_00014;
   g_tmp_F_00016= 2.* a.^ (2- 1).* g_a;
   tmp_F_00016= a.^ 2;
   g_tmp_sin_00010= g_theta.* cos(theta);
   tmp_sin_00010= sin(theta);
   g_tmp_F_00017= g_dxs.* tmp_sin_00010+ dxs.* g_tmp_sin_00010;
   tmp_F_00017= dxs.* tmp_sin_00010;
   g_tmp_cos_00010= g_theta.* (-sin(theta));
   tmp_cos_00010= cos(theta);
   g_tmp_F_00018= g_dys.* tmp_cos_00010+ dys.* g_tmp_cos_00010;
   tmp_F_00018= dys.* tmp_cos_00010;
   g_tmp_F_00019= g_tmp_F_00017+ g_tmp_F_00018;
   tmp_F_00019= tmp_F_00017+ tmp_F_00018;
   g_tmp_F_00020= 2.* tmp_F_00019.^ (2- 1).* g_tmp_F_00019;
   tmp_F_00020= tmp_F_00019.^ 2;
   g_tmp_F_00021= g_tmp_F_00016.* tmp_F_00020+ tmp_F_00016.* g_tmp_F_00020;
   tmp_F_00021= tmp_F_00016.* tmp_F_00020;
   g_tmp_F_00022= g_tmp_F_00015+ g_tmp_F_00021;
   tmp_F_00022= tmp_F_00015+ tmp_F_00021;
   Q= sqrt(tmp_F_00022); 
   
   g_Q= g_tmp_F_00022./ (2.* Q);
   g_tmp_F_00023= 2.* a.^ (2- 1).* g_a;
   tmp_F_00023= a.^ 2;
   g_tmp_cos_00011= g_theta.* (-sin(theta));
   tmp_cos_00011= cos(theta);
   g_tmp_F_00024= g_tmp_F_00023.* tmp_cos_00011.* P1+ tmp_F_00023.* g_tmp_cos_00011.* P1+ tmp_F_00023.* tmp_cos_00011.* g_P1;
   tmp_F_00024= tmp_F_00023.* tmp_cos_00011.* P1;
   g_tmp_F_00025= 2.* b.^ (2- 1).* g_b;
   tmp_F_00025= b.^ 2;
   g_tmp_sin_00011= g_theta.* cos(theta);
   tmp_sin_00011= sin(theta);
   g_tmp_F_00026= g_tmp_F_00025.* tmp_sin_00011.* P2+ tmp_F_00025.* g_tmp_sin_00011.* P2+ tmp_F_00025.* tmp_sin_00011.* g_P2;
   tmp_F_00026= tmp_F_00025.* tmp_sin_00011.* P2;
   g_tmp_F_00027= g_tmp_F_00024- g_tmp_F_00026;
   tmp_F_00027= tmp_F_00024- tmp_F_00026;
   g_tmp_F_00028= (g_tmp_F_00027.* Q- tmp_F_00027.* g_Q)./ Q.^ 2;
   tmp_F_00028= tmp_F_00027./ Q;
   g_tmp_sin_00012= g_theta.* cos(theta);
   tmp_sin_00012= sin(theta);
   g_tmp_F_00029= g_c.* tmp_sin_00012+ c.* g_tmp_sin_00012;
   tmp_F_00029= c.* tmp_sin_00012;
   g_dx= g_tmp_F_00028+ g_tmp_F_00029;
   dx= tmp_F_00028+ tmp_F_00029; 
   g_tmp_F_00030= 2.* a.^ (2- 1).* g_a;
   tmp_F_00030= a.^ 2;
   g_tmp_F_00031= -g_tmp_F_00030;
   tmp_F_00031= -tmp_F_00030;
   g_tmp_sin_00013= g_theta.* cos(theta);
   tmp_sin_00013= sin(theta);
   g_tmp_F_00032= g_tmp_F_00031.* tmp_sin_00013.* P1+ tmp_F_00031.* g_tmp_sin_00013.* P1+ tmp_F_00031.* tmp_sin_00013.* g_P1;
   tmp_F_00032= tmp_F_00031.* tmp_sin_00013.* P1;
   g_tmp_F_00033= 2.* b.^ (2- 1).* g_b;
   tmp_F_00033= b.^ 2;
   g_tmp_cos_00012= g_theta.* (-sin(theta));
   tmp_cos_00012= cos(theta);
   g_tmp_F_00034= g_tmp_F_00033.* tmp_cos_00012.* P2+ tmp_F_00033.* g_tmp_cos_00012.* P2+ tmp_F_00033.* tmp_cos_00012.* g_P2;
   tmp_F_00034= tmp_F_00033.* tmp_cos_00012.* P2;
   g_tmp_F_00035= g_tmp_F_00032- g_tmp_F_00034;
   tmp_F_00035= tmp_F_00032- tmp_F_00034;
   g_tmp_F_00036= (g_tmp_F_00035.* Q- tmp_F_00035.* g_Q)./ Q.^ 2;
   tmp_F_00036= tmp_F_00035./ Q;
   g_tmp_cos_00013= g_theta.* (-sin(theta));
   tmp_cos_00013= cos(theta);
   g_tmp_F_00037= g_c.* tmp_cos_00013+ c.* g_tmp_cos_00013;
   tmp_F_00037= c.* tmp_cos_00013;
   g_dy= g_tmp_F_00036+ g_tmp_F_00037;
   dy= tmp_F_00036+ tmp_F_00037; 
   
end



% còpia de itegració_real.m
% % Funció que calcula la distància entre un conjunt d'isòchrones i un altre
% % al llarg de la direcció de propagació RoS!
% %  DADES  
% %     tf=1;
% %     Nds=50;
% %     theta=0;
% %     s=0:2*pi/(Nds-1):2*pi;
% %     n=length(s);
% %     x=zeros(n-1,tf+1); %+1 to close the perimeter last point equals first
% %     y=zeros(n-1,tf+1);      %NO S=HA DE TANCAR EL PERIMETRE AQUI!!
% %     r=1; %m %initial radius
% %     xi=0.8*r.*cos(s)';
% %     yi=0.1*r.*sin(s)';
% %     close it NOOO És UN ERROR
% %     xi(n+1,1)=xi(1,1); %fallava pq si augmentes la dimensió es creen zeros
% %     yi(n+1,1)=yi(1,1);
% %     x(:,1)=xi(1:end-1);
% %     y(:,1)=yi(1:end-1);
% %     a=1.2; %(m/min)
% %     b=2.4;
% %     c=3.6;
% % 
% % for t=1:1:tf
% % t=1;
% %     centered diferences
% %     dxs=([x(2:end,t);x(1,t)]-[x(end,t);x(1:end-1,t)])./2;
% %     dys=([y(2:end,t);y(1,t)]-[y(end,t);y(1:end-1,t)])./2;
% %         dxs=diff(x(:,t));
% %         dxs=[dxs;(x(1,t)-x(end,t))];
% %         dys=diff(y(:,1));
% %         dys=[dys;(y(1,t)-y(end,t))];
% %     
% %     P1=dxs.*sin(theta)+dys.*cos(theta);
% %     P2=dxs.*cos(theta)-dys.*sin(theta);
% %     Q=sqrt(b.^2.*(dxs.*cos(theta)-dys.*sin(theta)).^2+a.^2.*(dxs.*sin(theta)+dys.*cos(theta)).^2);
% %         
% %     dx=(a.^2.*cos(theta).*(dxs.*sin(theta)+dys.*cos(theta))-b.^2.*sin(theta).*(dxs.*cos(theta)-dys.*sin(theta)))./sqrt(b.^2.*(dxs.*cos(theta)-dys.*sin(theta)).^2+a.^2.*(dxs.*sin(theta)+dys.*cos(theta)).^2)+c.*sin(theta);
% %     dy=(-a.^2.*sin(theta).*(dxs.*sin(theta)+dys.*cos(theta))-b.^2.*sin(theta).*(dxs.*cos(theta)-dys.*sin(theta)))./sqrt(b.^2.*(dxs.*cos(theta)-dys.*sin(theta)).^2+a.^2.*(dxs.*sin(theta)+dys.*cos(theta)).^2)+c.*cos(theta);
% %     
% %     dx = (a.^2.*cos(theta).*P1-b.^2.*sin(theta).*P2)./Q+c.*sin(theta);
% %     dy =(-a.^2.*sin(theta).*P1-b.^2.*cos(theta).*P2)./Q+c.*cos(theta);
% %     
% %     Preditor
% %     redefinit a,b,c
% %     x(:,t+1)=x(:,t)+dt.*dx;
function c= combnk(v, k)
   %COMBNK All combinations of the N elements in V taken K at a time.
   %   C = COMBNK(V,K) produces a matrix, with K columns. Each row of C has
   %   K of the elements in the vector V. C has N!/K!(N-K)! rows.  K must be
   %   a nonnegative integer.
   
   %   Copyright 1993-2004 The MathWorks, Inc. 
   
   
   [m, n]= size(v); 
   
   if min(m, n)~= 1
      error(message('stats:combnk:VectorRequired')); 
   end
   
   if n== 1
      n= m; 
      flag= 1; 
   else 
      flag= 0; 
   end
   
   if n== k
      c= v(: ).' ; 
   elseif n== k+ 1
      tmp= v(: ).' ; 
      c= tmp(ones(n, 1), : ); 
      c(1: n+ 1: n* n)= []; 
      tmp_combnk_00000= reshape(c, n, n- 1); 
      % Update detected: c= some_expression(c,...)
      c= tmp_combnk_00000;
   elseif k== 1
      c= v.' ; 
   elseif n< 17&& (k> 3|| n- k< 4)
      rows= 2.^ n; 
      ncycles= rows; 
      
      for count= 1: n
         settings= 0: 1; 
         tmp_combnk_00001= ncycles/ 2; 
         % Update detected: ncycles= some_expression(ncycles,...)
         ncycles= tmp_combnk_00001;
         nreps= rows./ (2* ncycles); 
         tmp_combnk_00002= settings(ones(1, nreps), : ); 
         % Update detected: settings= some_expression(settings,...)
         settings= tmp_combnk_00002;
         tmp_combnk_00003= settings(: ); 
         % Update detected: settings= some_expression(settings,...)
         settings= tmp_combnk_00003;
         tmp_combnk_00004= settings(: , ones(1, ncycles)); 
         % Update detected: settings= some_expression(settings,...)
         settings= tmp_combnk_00004;
         x(: , n- count+ 1)= settings(: ); 
      end
      
      idx= x(sum(x, 2)== k, : ); 
      nrows= size(idx, 1); 
      [rows, ignore]= find(idx' ); 
      c= reshape(v(rows), k, nrows).' ; 
   else 
      P= []; 
      if flag== 1, 
         tmp_combnk_00005= v.' ; 
         % Update detected: v= some_expression(v,...)
         v= tmp_combnk_00005;
      end
      if k< n&& k> 1
         for idx= 1: n- k+ 1
            Q= combnk(v(idx+ 1: n), k- 1); 
            tmp_combnk_00006= [P;
               [v(ones(size(Q, 1), 1), idx), Q]]; 
            % Update detected: P= some_expression(P,...)
            P= tmp_combnk_00006;
         end
      end
      c= P; 
   end
end
function [g_xy_inter, xy_inter, int_adj]= g_intersect2segments(g_Vxy1, Vxy1, g_Vxy2, Vxy2)
   % MODIFICAR per acceptar matrius fetes
   % FALLA QUAN NOMÉS S'INTRUDEIX UN VECTOR I NO INTERSECCIONA!!!
   % Adapted from: [intersect_flag]= intersect4points(xy1, xy2)
   % finds if segment xy1 intersects with segment xy2
   %
   %  If doesn't intersect xy_inter=NaN
   %  INPUTS
   %   Vxy1,Vxy2       = Nx4 aray with [x_i y_i x_f y_f]
   %
   % OUTPUTS
   %   xy_inter        = [x_inter, y_inter]
   %   int_adj  = adjacent intersection matrix; 0= no intersection; 1=intersection
   %
   % ALGORITHM
   % r= p2-p1
   % s= p4-p3
   % u = (p3 - p1) × r / (r × s)
   % intersect_flag=s1 ifonly u<1
   %
   % Now there are five cases:
   %
   % -If r × s = 0 and (q ? p) × r = 0, then the two lines are collinear. If in
   %       addition, either 0 ? (q ? p) · r ? r · r or 0 ? (p ? q) · s ? s · s, then
   %       the two lines are overlapping. NOT POSSIBLE HERE
   % -If r × s = 0 and (q ? p) × r = 0, but neither 0 ? (q ? p) · r ? r · r
   %       nor 0 ? (p ? q) · s ? s · s, then the two lines are collinear but disjoint.
   % -If r × s = 0 and (q ? p) × r ? 0, then the two lines are parallel and non-intersecting.
   % -If r × s ? 0 and 0 ? t ? 1 and 0 ? u ? 1, the two line segments meet at the point p + t r = q + u s.
   % Otherwise, the two line segments are not parallel but do not intersect.?¿?
   
   if size(Vxy1)~= size(Vxy2)
      error('MyErr: Size Vxy1~Vxy2!!!')
   end
   
   g_tmp_Vxy1_00000= g_Vxy1(: , 3);
   tmp_Vxy1_00000= Vxy1(: , 3);
   g_tmp_Vxy1_00001= g_Vxy1(: , 1);
   tmp_Vxy1_00001= Vxy1(: , 1);
   g_tmp_intersect2segments_00000= g_tmp_Vxy1_00000- g_tmp_Vxy1_00001;
   tmp_intersect2segments_00000= tmp_Vxy1_00000- tmp_Vxy1_00001;
   g_tmp_Vxy1_00002= g_Vxy1(: , 4);
   tmp_Vxy1_00002= Vxy1(: , 4);
   g_tmp_Vxy1_00003= g_Vxy1(: , 2);
   tmp_Vxy1_00003= Vxy1(: , 2);
   g_tmp_intersect2segments_00001= g_tmp_Vxy1_00002- g_tmp_Vxy1_00003;
   tmp_intersect2segments_00001= tmp_Vxy1_00002- tmp_Vxy1_00003;
   g_r= [g_tmp_intersect2segments_00000, g_tmp_intersect2segments_00001];
   r= [tmp_intersect2segments_00000, tmp_intersect2segments_00001]; 
   g_tmp_Vxy2_00000= g_Vxy2(: , 3);
   tmp_Vxy2_00000= Vxy2(: , 3);
   g_tmp_Vxy2_00001= g_Vxy2(: , 1);
   tmp_Vxy2_00001= Vxy2(: , 1);
   g_tmp_intersect2segments_00002= g_tmp_Vxy2_00000- g_tmp_Vxy2_00001;
   tmp_intersect2segments_00002= tmp_Vxy2_00000- tmp_Vxy2_00001;
   g_tmp_Vxy2_00002= g_Vxy2(: , 4);
   tmp_Vxy2_00002= Vxy2(: , 4);
   g_tmp_Vxy2_00003= g_Vxy2(: , 2);
   tmp_Vxy2_00003= Vxy2(: , 2);
   g_tmp_intersect2segments_00003= g_tmp_Vxy2_00002- g_tmp_Vxy2_00003;
   tmp_intersect2segments_00003= tmp_Vxy2_00002- tmp_Vxy2_00003;
   g_s= [g_tmp_intersect2segments_00002, g_tmp_intersect2segments_00003];
   s= [tmp_intersect2segments_00002, tmp_intersect2segments_00003]; 
   
   g_tmp_r_00000= g_r(: , 1);
   tmp_r_00000= r(: , 1);
   g_tmp_s_00000= g_s(: , 2);
   tmp_s_00000= s(: , 2);
   g_tmp_intersect2segments_00004= g_tmp_r_00000.* tmp_s_00000+ tmp_r_00000.* g_tmp_s_00000;
   tmp_intersect2segments_00004= tmp_r_00000.* tmp_s_00000;
   g_tmp_r_00001= g_r(: , 2);
   tmp_r_00001= r(: , 2);
   g_tmp_s_00001= g_s(: , 1);
   tmp_s_00001= s(: , 1);
   g_tmp_intersect2segments_00005= g_tmp_r_00001.* tmp_s_00001+ tmp_r_00001.* g_tmp_s_00001;
   tmp_intersect2segments_00005= tmp_r_00001.* tmp_s_00001;
   g_cross_r_s= g_tmp_intersect2segments_00004- g_tmp_intersect2segments_00005;
   cross_r_s= tmp_intersect2segments_00004- tmp_intersect2segments_00005; 
   
   %if cross_r_s~=0 %meaning intersection MODIFICAR AIXÖ!!! VECTORITZAR!! PETA
   %SI UN FALS!!!! SEMBLA QUE ARA SIII
   
   tmp_intersect2segments_00006= 1: 2;
   g_tmp_Vxy2_00004= g_Vxy2(: , tmp_intersect2segments_00006);
   tmp_Vxy2_00004= Vxy2(: , tmp_intersect2segments_00006);
   tmp_intersect2segments_00007= 1: 2;
   g_tmp_Vxy1_00004= g_Vxy1(: , tmp_intersect2segments_00007);
   tmp_Vxy1_00004= Vxy1(: , tmp_intersect2segments_00007);
   g_tmp_intersect2segments_00008= g_tmp_Vxy2_00004- g_tmp_Vxy1_00004;
   tmp_intersect2segments_00008= tmp_Vxy2_00004- tmp_Vxy1_00004;
   g_q_p= g_tmp_intersect2segments_00008;
   q_p= tmp_intersect2segments_00008; 
   
   cross_q_p_r= q_p(: , 1).* r(: , 2)- q_p(: , 2).* r(: , 1); 
   g_tmp_q_p_00000= g_q_p(: , 1);
   tmp_q_p_00000= q_p(: , 1);
   g_tmp_s_00002= g_s(: , 2);
   tmp_s_00002= s(: , 2);
   g_tmp_intersect2segments_00009= g_tmp_q_p_00000.* tmp_s_00002+ tmp_q_p_00000.* g_tmp_s_00002;
   tmp_intersect2segments_00009= tmp_q_p_00000.* tmp_s_00002;
   g_tmp_q_p_00001= g_q_p(: , 2);
   tmp_q_p_00001= q_p(: , 2);
   g_tmp_s_00003= g_s(: , 1);
   tmp_s_00003= s(: , 1);
   g_tmp_intersect2segments_00010= g_tmp_q_p_00001.* tmp_s_00003+ tmp_q_p_00001.* g_tmp_s_00003;
   tmp_intersect2segments_00010= tmp_q_p_00001.* tmp_s_00003;
   g_cross_q_p_s= g_tmp_intersect2segments_00009- g_tmp_intersect2segments_00010;
   cross_q_p_s= tmp_intersect2segments_00009- tmp_intersect2segments_00010; 
   
   u= cross_q_p_r./ cross_r_s; 
   g_t= (g_cross_q_p_s.* cross_r_s- cross_q_p_s.* g_cross_r_s)./ cross_r_s.^ 2;
   t= cross_q_p_s./ cross_r_s; 
   
   %         if t>=0 && t<=1 && u>=0 && u<=1
   %         %if t>0 && t<1 && u>0 && u<1
   %             xy_inter=Vxy1(:,1:2)+t*r;
   %         end
   % VECTORITZACIÓ LÒGICA (també funciona d'un en un)
   %II=t>1.1 & t<0.0 & u>0.0 & u<1.0;
   % ACTIVAR l'IF pq no peti si no entra una matriu.
   if size(Vxy1, 1)== 1
      tmp_intersect2segments_00011= 1: 2;
      g_tmp_Vxy1_00005= g_Vxy1(: , tmp_intersect2segments_00011);
      tmp_Vxy1_00005= Vxy1(: , tmp_intersect2segments_00011);
      g_tmp_intersect2segments_00012= g_t* r+ t* g_r;
      tmp_intersect2segments_00012= t* r;
      g_xy_inter= g_tmp_Vxy1_00005+ g_tmp_intersect2segments_00012;
      xy_inter= tmp_Vxy1_00005+ tmp_intersect2segments_00012; 
      int_adj= ~isnan(xy_inter(1, 1)); 
   else 
      int_adj= t> 0.01& t< 0.99& u> 0.01& u< 0.99; % NO volem que si es toquen pel vertex sigui intersecció
      tmp_intersect2segments_00013= 1: 2;
      g_tmp_Vxy1_00006= g_Vxy1(int_adj, tmp_intersect2segments_00013);
      tmp_Vxy1_00006= Vxy1(int_adj, tmp_intersect2segments_00013);
      g_tmp_t_00000= g_t(int_adj);
      tmp_t_00000= t(int_adj);
      g_tmp_t_00001= g_t(int_adj);
      tmp_t_00001= t(int_adj);
      g_tmp_intersect2segments_00014= [g_tmp_t_00000, g_tmp_t_00001];
      tmp_intersect2segments_00014= [tmp_t_00000, tmp_t_00001];
      g_tmp_r_00002= g_r(int_adj, : );
      tmp_r_00002= r(int_adj, : );
      g_tmp_intersect2segments_00015= g_tmp_intersect2segments_00014.* tmp_r_00002+ tmp_intersect2segments_00014.* g_tmp_r_00002;
      tmp_intersect2segments_00015= tmp_intersect2segments_00014.* tmp_r_00002;
      g_xy_inter= g_tmp_Vxy1_00006+ g_tmp_intersect2segments_00015;
      xy_inter= tmp_Vxy1_00006+ tmp_intersect2segments_00015; 
      %int_adj=int_adj;
   end
end
%cases
%intersect_flag=zeros(length(u),1);
%filtering cases
%intersect_flag(isinf(intersect_flag))=0;
%intersect_flag(isnan(intersect_flag))=0;
%intersect_flag(0<u & u<1)=1;

%end
